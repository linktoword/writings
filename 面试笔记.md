# 面试笔记

## Vue篇

### 1. vue生命周期的理解

   - `beforeCreate`： 组件创建前 此时 data和$el 未初始化 
   - `created` ：组件创建后  此时 data已初始化但是 $el 未初始化 
   - `beforeMount`： 完成了$le和data的初始化 并且在内存中生成虚拟dom但是尚未挂载到页面当中去， 真是dom还未被替换
   - `mounted`： 完成虚拟dom挂载 真实dom完成数据绑定，此时Vue实例已经初始化完毕，组件脱离创建阶段，到了运行阶段
   - `beforeUpdate`： 组件数据更新前调用，发生在虚拟dom打补丁之前；此时页面显示的仍是旧数据，但是data内的数据已经是最新的了，页面尚未和最新数据同步
   - `updated`： 组件数据更新之后，页面和data数据保持同步
   - `beforeDestroy`：组件销毁前调用；组件进入销毁阶段；此时实例所有的数据和方法等都处于可用状态，还未真正执行销毁过程；
   - `destroyed`：组件销毁后调用；此时组件已经被完全销毁，所有的数据和方法等不可用；
   - `activated`：keep-alive专属 组件被激活时调用
   - `deactivated`: keep-alive专属 组件失活时调用
   - `errorCaptured`(2.5.0+ 新增)：当捕获一个来自子孙组件的错误时被调用
- `serverPrefetch`(v2.6+)
  
### 2. Vue 的父组件和子组件生命周期钩子函数执行顺序

   - 加载渲染过程

     父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

### 3. Vue组件之间的通讯方式
   - `props`和`$emit`：组件通讯最常用方式 适用于父子组件通讯
   - `ref`与 `$parnet/$children` ：适用于父子组件通讯
   - EventBus($emit / $on)：适合父子 隔代 兄弟组件通讯
   - Vuex： 专为 Vue.js 应用程序开发的状态管理模式
   - `$attrs`/`$listeners` 适用于 隔代组件通信 爷孙组件通讯
   - `provide / inject` 适用于 隔代组件通信 provide 可以在祖先组件中指定我们想要提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法

### 4. v-modal的原理

   - v-modal本质上是个语法糖 在表单等元素上创建双向数据绑定，其中text和textarea元素使用value属性和input事件；checkbox和radio使用checked属性和change事件；select字段 将value作为prop和change作为事件；

   - 自定义组价中 v-modal默认利用 名为value的prop和input事件；

     ```
     父组件：
     <my-child v-model="message"></my-child>
     
     子组件：
     <div>{{value}}</div>
     
     props:{
         value: String
     },
     methods: {
       test1(){
          this.$emit('input', '我是一个信息')
       }
     }
     ```

### 5. SPA单页面的理解，他们的优缺点是什么？

SPA（singel-page application）仅在初始时加载相应的html，css，js。一旦页面加载完成，SPA页面不会因用户的操作而进行页面的重新加载或跳转，主要利用路由机制实现html的变换，避免页面的重新加载；

​        **优点**：	

- 用户体验好，路由之间跳转可定制跳转动画；

- 使用懒加载可减少首页白屏时间，相对于多页面减少了用户访问静态资源服务器的次数等；

- 前后端分离，架构清晰，前端进行交互逻辑，后端负责处理数据；

  **缺点：** 

- 载耗时多。可 构建骨架图、压缩代码，缓存措施，懒加载等；
- 不利于SEO，网站内容在一个页面中利用js进行动态显示和替换，不利于进行SEO，可以做些静态页面给搜索引擎用或者 `#!`号代替`#`号，因为谷歌会抓取带有`#!`的URL；
- 前进后退路由管理：单页面应用在一个页面显示所有内容，不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈；

### 6. 理解Vue单项数据流

数据是从父组件传递给子组件，只能单向绑定；子组件内部不能直接修改从父组件传递过来的数据。

所有的prop都使得其父子prop之间形成一个单向下行的绑定：父级prop的更新会向下流动到子组件，但是反过来不行；这样防止子组件意外改变父组件的状态，从而导致应用数据流向难以理解；

### 7. 直接给数组赋值， Vue能检测到变化吗？

不能；由于js的限制 Vue不能检测到一下变化

- 利用索引直接设置一个数组项时；

- 修改数组的长度时；

  第一个解决办法： 

  - `Vue.set( target, key, value )`
    - target：要更改的数据源(可以是对象或者数组)
    - key：要更改的具体数据
    - value ：重新赋的值

  第二个解决办法： 

  `vm.items.splice(newLength)`

  







