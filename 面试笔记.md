# 面试笔记

## Vue篇

### 1. vue生命周期的理解

   - `beforeCreate`： 组件创建前 此时 data和$el 未初始化 
   - `created` ：组件创建后  此时 data已初始化但是 $el 未初始化 
   - `beforeMount`： 完成了$le和data的初始化 并且在内存中生成虚拟dom但是尚未挂载到页面当中去， 真是dom还未被替换
   - `mounted`： 完成虚拟dom挂载 真实dom完成数据绑定，此时Vue实例已经初始化完毕，组件脱离创建阶段，到了运行阶段
   - `beforeUpdate`： 组件数据更新前调用，发生在虚拟dom打补丁之前；此时页面显示的仍是旧数据，但是data内的数据已经是最新的了，页面尚未和最新数据同步
   - `updated`： 组件数据更新之后，页面和data数据保持同步
   - `beforeDestroy`：组件销毁前调用；组件进入销毁阶段；此时实例所有的数据和方法等都处于可用状态，还未真正执行销毁过程；
   - `destroyed`：组件销毁后调用；此时组件已经被完全销毁，所有的数据和方法等不可用；
   - `activated`：keep-alive专属 组件被激活时调用
   - `deactivated`: keep-alive专属 组件失活时调用
   - `errorCaptured`(2.5.0+ 新增)：当捕获一个来自子孙组件的错误时被调用
- `serverPrefetch`(v2.6+)
  
### 2. Vue 的父组件和子组件生命周期钩子函数执行顺序

   - 加载渲染过程

     父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

### 3. Vue组件之间的通讯方式
   - `props`和`$emit`：组件通讯最常用方式 适用于父子组件通讯
   - `ref`与 `$parnet/$children` ：适用于父子组件通讯
   - EventBus($emit / $on)：适合父子 隔代 兄弟组件通讯
   - Vuex： 专为 Vue.js 应用程序开发的状态管理模式
   - `$attrs`/`$listeners` 适用于 隔代组件通信 爷孙组件通讯
   - `provide / inject` 适用于 隔代组件通信 provide 可以在祖先组件中指定我们想要提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法

### 4. v-modal的原理

   - v-modal本质上是个语法糖 在表单等元素上创建双向数据绑定，其中text和textarea元素使用value属性和input事件；checkbox和radio使用checked属性和change事件；select字段 将value作为prop和change作为事件；

   - 自定义组价中 v-modal默认利用 名为value的prop和input事件；

     ```
     父组件：
     <my-child v-model="message"></my-child>
     
     子组件：
     <div>{{value}}</div>
     
     props:{
         value: String
     },
     methods: {
       test1(){
          this.$emit('input', '我是一个信息')
       }
     }
     ```

### 5. SPA单页面的理解，他们的优缺点是什么？

SPA（singel-page application）仅在初始时加载相应的html，css，js。一旦页面加载完成，SPA页面不会因用户的操作而进行页面的重新加载或跳转，主要利用路由机制实现html的变换，避免页面的重新加载；

​        **优点**：	

- 用户体验好，路由之间跳转可定制跳转动画；

- 使用懒加载可减少首页白屏时间，相对于多页面减少了用户访问静态资源服务器的次数等；

- 前后端分离，架构清晰，前端进行交互逻辑，后端负责处理数据；

  **缺点：** 

- 载耗时多。可 构建骨架图、压缩代码，缓存措施，懒加载等；
- 不利于SEO，网站内容在一个页面中利用js进行动态显示和替换，不利于进行SEO，可以做些静态页面给搜索引擎用或者 `#!`号代替`#`号，因为谷歌会抓取带有`#!`的URL；
- 前进后退路由管理：单页面应用在一个页面显示所有内容，不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈；

### 6. 理解Vue单项数据流

数据是从父组件传递给子组件，只能单向绑定；子组件内部不能直接修改从父组件传递过来的数据。

所有的prop都使得其父子prop之间形成一个单向下行的绑定：父级prop的更新会向下流动到子组件，但是反过来不行；这样防止子组件意外改变父组件的状态，从而导致应用数据流向难以理解；

### 7. 直接给数组赋值， Vue能检测到变化吗？

不能；由于js的限制 Vue不能检测到一下变化

- 利用索引直接设置一个数组项时；

- 修改数组的长度时；

  第一个解决办法： 

  - `Vue.set( target, key, value )`
    - target：要更改的数据源(可以是对象或者数组)
    - key：要更改的具体数据
    - value ：重新赋的值

  第二个解决办法： 

  `vm.items.splice(newLength)`

# JavaScript篇

## 1. Promise

Promise是一个对象，表示一个异步操作的结果，有三种状态：进行中`pending` 、已成功`fulfilled`、已失败`rejected`；Promise具有`.then() .catch()`方法会返回一个新的Promise，所以可以允许我们链式回调，避免了层层嵌套的回调函数；

Promise有两个特点： 

1. 对象状态的改变只有当前异步操作的结果决定，不受外界影响；
2. 对象状态一旦改变，就不会再变；

#### `.then()`和`.catch()`方法:

1. 都会返回一个新的Promise；
2. Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止`.catch()`不管连接到哪里都能捕获上层未能捕捉到的错误；
3. 在Promise中返回一个非Promise都会被包裹成Promise对象；
4. Promise可以被`.then()`和`.catch()`调用多次，如果Promise内部状态已经改变，调用方法会直接拿到该值；
5. `.then()`和`.catch()`中return一个`error`对象并不会抛出错误，无法被`.catch`捕捉到；
6. `.then()`方法接受两个参数，第一个参数是`resolved`状态的回调函数，第二个参数（可选）是rejected状态的回调函数
7. `.catch()`方法为`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。Promise对象异步操作内部抛出错误状态变成`rejected`或者运行中抛出错误就会被`catch()`捕捉到；
8. `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。
9. Promise 对象抛出的错误不会传递到外层代码

#### `.finally()`方法：

1. `.finally()`方法不管`Promise`对象最后的状态如何都会执行；
2. `finally`方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
3. `finally`方法总是会返回原来的值。

#### `.all()`方法：

1. 方法接收一组数组作为参数，数组中都是Promise的实例；如果不是，就先调用`Promise.resolve`方法，将参数转为 Promise 实例，再进一步处理。`Promise.all()`方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。
2. `.all()`的状态有内部实例的状态决定，分两种情况：
   - 所有的参数实例的状态都变成`fulfilled`，`.all()`的状态才会变成`fulfilled`，此时参数实例的返回值组成一个数组，传递给`.all()`的回调函数。
   - 只要参数实例中有一个实例的状态变成`rejected`，`.all()`的状态才会变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数，但并不会影响数组中其它的异步任务的执行。
3. 如果作为参数的 Promise 实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法。

#### `.race()`方法：

`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

只要参数数组中的一个实例率先改变状态，`Promise.race()`实例的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`Promise.race()`实例的回调函数。

#### `.allSettled()`方法：（该方法由 [ES2020](https://github.com/tc39/proposal-promise-allSettled) 引入）

1. `Promise.allSettled()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束。

2. 包装实例的最后状态总是`fulfilled`，不会变成`rejected`。
3. 包装实例的监听函数接收到的参数是一个数组，每个成员对应一个传入`Promise.allSettled()`的 Promise 实例结果对象。每个对象都有`status`属性，该属性的值只可能是字符串`fulfilled`或字符串`rejected`。`fulfilled`时，对象有`value`属性，`rejected`时有`reason`属性，对应两种状态的返回值。

#### `.any()`方法：

`Promise.any()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。该方法目前是一个第三阶段的[提案](https://github.com/tc39/proposal-promise-any) 。

#### `.resolve()`方法：

将现有对象转为 Promise 对象，`Promise.resolve()`方法就起到这个作用

1. **参数是一个 Promise 实例**

如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例。

2. **参数是一个`thenable`对象**

`thenable`对象指的是具有`then`方法的对象；`Promise.resolve`方法会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then`方法。

3. **参数不是具有`then`方法的对象，或根本就不是对象**

如果参数是一个原始值，或者是一个不具有`then`方法的对象，则`Promise.resolve`方法返回一个新的 Promise 对象，状态为`resolved`。

4. **不带有任何参数**

`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象。

#### `.rejected()`:方法

`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。

`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。

#### `.try()`方法： 

`Promise.try`为所有操作提供了统一的处理机制，所以如果想用`then`方法管理流程，最好都用`Promise.try`包装一下

好处：更好地管理异常。更好的互操作性 易于浏览



